/**
 * WebGLRenderer.test.js - Test suite for WebGLRenderer class
 *
 * TDD Approach: Write tests first, then implement
 *
 * Test Coverage:
 * - Renderer initialization and WebGL context creation
 * - Shader compilation and program linking
 * - Buffer creation (vertex, instance data)
 * - Texture upload from GlyphAtlas
 * - Full terminal rendering
 * - Dirty region optimization
 * - Cursor rendering
 * - Resize handling
 * - Performance benchmarks
 */

const { describe, it, expect, beforeEach } = require('@jest/globals');
const createContext = require('gl');
const { createCanvas } = require('canvas');
const { createMockCanvas } = require('./helpers/mockCanvas');
const TerminalBuffer = require('../src/core/TerminalBuffer');
const GlyphAtlas = require('../src/renderer/GlyphAtlas');
const WebGLRenderer = require('../src/renderer/WebGLRenderer');

describe('WebGLRenderer', () => {
    let renderer;
    let gl;
    let buffer;
    let atlas;

    beforeEach(() => {
        // Create real WebGL context using headless-gl
        gl = createContext(800, 600);

        // Create terminal buffer
        buffer = new TerminalBuffer(80, 24);

        // Create glyph atlas with real canvas
        atlas = new GlyphAtlas({
            width: 512,
            height: 512,
            cellWidth: 10,
            cellHeight: 20,
            fontFamily: 'monospace',
            fontSize: 16,
            createCanvas: createCanvas // Use real canvas from 'canvas' package
        });

        // Pre-load some glyphs
        for (let i = 32; i < 127; i++) {
            atlas.getGlyph(String.fromCharCode(i), false, false, false, 0xFFFFFF);
        }
    });

    describe('Construction and Initialization', () => {
        it('should create renderer with GL context', () => {
            renderer = new WebGLRenderer(gl, buffer, atlas);
            expect(renderer).toBeDefined();
            expect(renderer.gl).toBe(gl);
        });

        it('should compile vertex shader without errors', () => {
            renderer = new WebGLRenderer(gl, buffer, atlas);
            const status = gl.getShaderParameter(renderer.vertexShader, gl.COMPILE_STATUS);
            expect(status).toBe(true);
        });

        it('should compile fragment shader without errors', () => {
            renderer = new WebGLRenderer(gl, buffer, atlas);
            const status = gl.getShaderParameter(renderer.fragmentShader, gl.COMPILE_STATUS);
            expect(status).toBe(true);
        });

        it('should link shader program without errors', () => {
            renderer = new WebGLRenderer(gl, buffer, atlas);
            const status = gl.getProgramParameter(renderer.program, gl.LINK_STATUS);
            expect(status).toBe(true);
        });

        it('should create vertex buffer for quad geometry', () => {
            renderer = new WebGLRenderer(gl, buffer, atlas);
            expect(renderer.quadBuffer).toBeDefined();
        });

        it('should create instance buffer for all cells', () => {
            renderer = new WebGLRenderer(gl, buffer, atlas);
            expect(renderer.instanceBuffer).toBeDefined();
        });

        it('should upload glyph atlas texture to GPU', () => {
            renderer = new WebGLRenderer(gl, buffer, atlas);
            expect(renderer.atlasTexture).toBeDefined();
        });
    });

    describe('Shader Management', () => {
        it('should load shader source from files', () => {
            renderer = new WebGLRenderer(gl, buffer, atlas);
            // Shaders are loaded in constructor, verify they exist
            expect(renderer.vertexShader).toBeDefined();
            expect(renderer.fragmentShader).toBeDefined();
            expect(renderer.program).toBeDefined();
        });

        it('should handle shader compilation errors', () => {
            // Create bad shader source by mocking fs.readFileSync
            const fs = require('fs');
            const originalReadFileSync = fs.readFileSync;
            jest.spyOn(fs, 'readFileSync').mockReturnValueOnce('INVALID GLSL CODE!!!');

            expect(() => {
                renderer = new WebGLRenderer(gl, buffer, atlas);
            }).toThrow(/Shader compilation failed/);

            fs.readFileSync.mockRestore();
        });

        it('should handle program linking errors', () => {
            // Mock createProgram to return a program that fails to link
            const originalCreateProgram = gl.createProgram;
            const originalLinkProgram = gl.linkProgram;
            const originalGetProgramParameter = gl.getProgramParameter;

            gl.createProgram = jest.fn(() => {
                const program = originalCreateProgram.call(gl);
                return program;
            });

            gl.getProgramParameter = jest.fn((program, pname) => {
                if (pname === gl.LINK_STATUS) return false;
                return originalGetProgramParameter.call(gl, program, pname);
            });

            expect(() => {
                renderer = new WebGLRenderer(gl, buffer, atlas);
            }).toThrow(/Shader program link failed/);

            gl.createProgram = originalCreateProgram;
            gl.getProgramParameter = originalGetProgramParameter;
        });

        it('should locate uniform locations', () => {
            renderer = new WebGLRenderer(gl, buffer, atlas);
            expect(renderer.uniforms.resolution).not.toBe(null);
            expect(renderer.uniforms.cellSize).not.toBe(null);
            expect(renderer.uniforms.glyphAtlas).not.toBe(null);
        });

        it('should locate attribute locations', () => {
            renderer = new WebGLRenderer(gl, buffer, atlas);
            expect(renderer.attribs.position).not.toBe(-1);
            expect(renderer.attribs.texCoord).not.toBe(-1);
            expect(renderer.attribs.cellPosition).not.toBe(-1);
            expect(renderer.attribs.glyphCoords).not.toBe(-1);
            expect(renderer.attribs.fgColor).not.toBe(-1);
            expect(renderer.attribs.bgColor).not.toBe(-1);
            expect(renderer.attribs.flags).not.toBe(-1);
        });
    });

    describe('Buffer Management', () => {
        it('should update instance buffer with cell data', () => {
            renderer = new WebGLRenderer(gl, buffer, atlas);

            // Fill buffer with some test data
            buffer.setCell(0, 0, new require('../src/core/Cell')('A', 0xFF0000, 0x000000));
            buffer.setCell(1, 0, new require('../src/core/Cell')('B', 0x00FF00, 0x000000));

            // Render should update instance buffer
            renderer.render();

            // Verify buffer was updated (check it doesn't throw)
            expect(renderer.instanceBuffer).toBeDefined();
        });

        it('should handle buffer resize', () => {
            renderer = new WebGLRenderer(gl, buffer, atlas);

            // Resize viewport
            renderer.resize(1024, 768);

            // Verify viewport was updated
            const viewport = gl.getParameter(gl.VIEWPORT);
            expect(viewport[2]).toBe(1024);
            expect(viewport[3]).toBe(768);
        });

        it('should use sub-buffer updates for dirty regions', () => {
            renderer = new WebGLRenderer(gl, buffer, atlas);

            // Mark specific cells as dirty
            buffer.setCell(5, 5, new require('../src/core/Cell')('X'));
            buffer.dirtyLines.add(5);

            // Render should handle dirty regions
            renderer.render();

            // Verify dirty was cleared
            expect(buffer.dirtyLines.size).toBe(0);
        });
    });

    describe('Texture Management', () => {
        it('should upload glyph atlas to GPU', () => {
            renderer = new WebGLRenderer(gl, buffer, atlas);
            // Texture uploaded in constructor
            expect(renderer.atlasTexture).toBeDefined();

            // Verify texture is bound
            gl.bindTexture(gl.TEXTURE_2D, renderer.atlasTexture);
            const bound = gl.getParameter(gl.TEXTURE_BINDING_2D);
            expect(bound).toBe(renderer.atlasTexture);
        });

        it('should update texture when atlas is dirty', () => {
            renderer = new WebGLRenderer(gl, buffer, atlas);

            // Mark atlas as dirty by adding new glyph
            atlas.getGlyph('Z', false, false, false, 0xFFFFFF);
            expect(atlas.isDirty()).toBe(true);

            // Render should clear dirty flag
            renderer.render();
            expect(atlas.isDirty()).toBe(false);
        });

        it('should use texture parameters for crisp rendering', () => {
            renderer = new WebGLRenderer(gl, buffer, atlas);

            gl.bindTexture(gl.TEXTURE_2D, renderer.atlasTexture);

            // Verify NEAREST filtering for crisp pixel art
            const minFilter = gl.getTexParameter(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER);
            const magFilter = gl.getTexParameter(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER);
            expect(minFilter).toBe(gl.NEAREST);
            expect(magFilter).toBe(gl.NEAREST);
        });
    });

    describe('Rendering', () => {
        it.skip('should render full terminal buffer', () => {
            expect(true).toBe(true);
        });

        it.skip('should render only dirty regions', () => {
            expect(true).toBe(true);
        });

        it.skip('should render cursor', () => {
            expect(true).toBe(true);
        });

        it.skip('should render blinking cursor', () => {
            expect(true).toBe(true);
        });

        it.skip('should use instanced rendering', () => {
            expect(true).toBe(true);
        });

        it.skip('should clear screen before rendering', () => {
            expect(true).toBe(true);
        });

        it.skip('should handle empty buffer', () => {
            expect(true).toBe(true);
        });
    });

    describe('Dirty Region Optimization', () => {
        it.skip('should track dirty lines', () => {
            expect(true).toBe(true);
        });

        it.skip('should render only dirty cells', () => {
            expect(true).toBe(true);
        });

        it.skip('should mark entire screen dirty on resize', () => {
            expect(true).toBe(true);
        });

        it.skip('should coalesce adjacent dirty regions', () => {
            expect(true).toBe(true);
        });
    });

    describe('Resize Handling', () => {
        it.skip('should resize canvas', () => {
            expect(true).toBe(true);
        });

        it.skip('should update viewport', () => {
            expect(true).toBe(true);
        });

        it.skip('should update projection uniforms', () => {
            expect(true).toBe(true);
        });

        it.skip('should reallocate buffers on size change', () => {
            expect(true).toBe(true);
        });
    });

    describe('Performance', () => {
        it.skip('should render 80x24 terminal in < 2ms', () => {
            expect(true).toBe(true);
        });

        it.skip('should render 200x100 terminal in < 5ms', () => {
            expect(true).toBe(true);
        });

        it.skip('should handle 60 FPS rendering', () => {
            expect(true).toBe(true);
        });

        it.skip('should use single draw call for full screen', () => {
            expect(true).toBe(true);
        });
    });

    describe('Error Handling', () => {
        it.skip('should handle WebGL context loss', () => {
            expect(true).toBe(true);
        });

        it.skip('should handle WebGL context restoration', () => {
            expect(true).toBe(true);
        });

        it.skip('should gracefully degrade if WebGL unavailable', () => {
            expect(true).toBe(true);
        });
    });
});
